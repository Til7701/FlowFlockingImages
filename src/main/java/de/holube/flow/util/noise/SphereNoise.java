package de.holube.flow.util.noise;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class SphereNoise {

    /**
     * Returns a noise value between 0 and 1. This is generated by using 3D noise. It maps the coordinates of the
     * rectangle to the sphere and returns the noise value at the calculated point.
     * <p>
     * https://math.libretexts.org/Bookshelves/Calculus/Book%3A_Calculus_(OpenStax)/12%3A_Vectors_in_Space/12.7%3A_Cylindrical_and_Spherical_Coordinates
     * https://en.wikipedia.org/wiki/Equirectangular_projection
     *
     * @param seed   The seed for the noise.
     * @param xR     The x coordinate on the rectangle.
     * @param yR     The y coordinate on the rectangle.
     * @param x      The x coordinate of the sphere.
     * @param y      The y coordinate of the sphere.
     * @param z      The z coordinate of the sphere.
     * @param radius The radius of the sphere.
     * @return A noise value between 0 and 1.
     */
    public static float noise(long seed, float xR, float yR, float xSize, float ySize, float x, float y, float z, float radius) {
        if (radius <= 0) {
            return 0;
        }

        float theta = (yR / ySize) * (float) Math.PI * 1.1F;
        float phi = (xR / xSize) * (float) Math.PI * 3.6F;

        return noise(seed, radius, theta, phi, x, y, z);
    }

    public static float noise(long seed, float rho, float theta, float phi, float x, float y, float z) {
        if (rho <= 0) {
            return 0;
        }

        float xPos = toRectangularX(rho, theta, phi) + x;
        float yPos = toRectangularY(rho, theta, phi) + y;
        float zPos = toRectangularZ(rho, phi) + z;

        return OpenSimplex2S.noise3_ImproveXY(seed, xPos, yPos, zPos);
    }

    public static float toRectangularX(float rho, float theta, float phi) {
        boolean negative = phi >= Math.PI / 2;
        if (negative)
            phi -= Math.PI;
        float x = (float) (rho * Math.sin(phi) * Math.cos(theta));
        if (negative)
            x = -x;
        return x;
    }

    public static float toRectangularY(float rho, float theta, float phi) {
        boolean negative = phi >= Math.PI / 2;
        if (negative)
            phi -= Math.PI;
        float y = (float) (rho * Math.sin(phi) * Math.sin(theta));
        if (negative)
            y = -y;
        return y;
    }

    public static float toRectangularZ(float rho, float phi) {
        boolean negative = phi >= Math.PI / 2;
        if (negative)
            phi -= Math.PI;
        float z = (float) (rho * Math.cos(phi));
        if (negative)
            z = -z;
        return z;
    }

}
